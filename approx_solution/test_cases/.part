#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <signal.h>
#include <pthread.h>

#include "graph.h"

#define MAX_TIME 5.0
#define NUM_THREADS 4

volatile sig_atomic_t interrupted = 0;

double now() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec + ts.tv_nsec / 1e9;
}

static void handle_signal(int sig) {
    (void)sig;
    interrupted = 1;
}

typedef struct {
    graph *g;
    float best_weight;
    size_t *best_path;
    size_t best_len;
    pthread_mutex_t lock;
    double last_improve;
} shared_t;

/* -----------------------------------------------
   4 heuristics rewritten to use per-thread buffers
   ----------------------------------------------- */

static float run_sim_basic(graph *g, size_t s,
                           size_t *tmp, size_t *len) {

    int *visited = calloc(g->n, sizeof(int));
    size_t current = s;

    *len = 0;
    tmp[(*len)++] = current;
    visited[current] = 1;

    float total = 0.0f;

    while (1) {
        edge *best = NULL;

        for (edge *e = g->adj[current]; e; e = e->next)
            if (!visited[e->to] && (!best || e->weight > best->weight))
                best = e;

        if (!best) break;

        total += best->weight;
        current = best->to;

        tmp[(*len)++] = current;
        visited[current] = 1;
    }

    free(visited);
    return total;
}

static float run_sim_tiebreak(graph *g, size_t s,
                              size_t *tmp, size_t *len) {

    int *visited = calloc(g->n, sizeof(int));
    size_t current = s;

    *len = 0;
    tmp[(*len)++] = current;
    visited[current] = 1;

    float total = 0.0f;

    while (1) {
        edge *best = NULL;

        for (edge *e = g->adj[current]; e; e = e->next) {
            if (visited[e->to]) continue;
            if (!best) best = e;
            else if (e->weight > best->weight) best = e;
            else if (e->weight == best->weight && (rand() % 2 == 0))
                best = e;
        }

        if (!best) break;

        total += best->weight;
        current = best->to;

        tmp[(*len)++] = current;
        visited[current] = 1;
    }

    free(visited);
    return total;
}

static float run_sim_tiebreak_8020(graph *g, size_t s,
                                   size_t *tmp, size_t *len) {

    int *visited = calloc(g->n, sizeof(int));
    size_t current = s;

    *len = 0;
    tmp[(*len)++] = current;
    visited[current] = 1;

    float total = 0.0f;

    while (1) {
        edge *best = NULL;
        edge *second = NULL;

        for (edge *e = g->adj[current]; e; e = e->next) {
            if (visited[e->to]) continue;

            if (!best) {
                best = e;
            } else if (e->weight > best->weight) {
                second = best;
                best = e;
            } else if (!second || e->weight > second->weight) {
                second = e;
            } else if (e->weight == best->weight && (rand() % 2 == 0)) {
                second = best;
                best = e;
            }
        }

        if (!best) break;

        edge *chosen = best;
        if (second && (rand() % 100 < 20))
            chosen = second;

        total += chosen->weight;
        current = chosen->to;

        tmp[(*len)++] = current;
        visited[current] = 1;
    }

    free(visited);
    return total;
}

static float run_sim_lookahead2(graph *g, size_t s,
                                size_t *tmp, size_t *len) {

    int *visited = calloc(g->n, sizeof(int));
    size_t current = s;

    *len = 0;
    tmp[(*len)++] = current;
    visited[current] = 1;

    float total = 0.0f;

    while (1) {
        edge *best = NULL;
        float best_score = -1e30f;

        for (edge *e = g->adj[current]; e; e = e->next) {
            if (visited[e->to]) continue;

            float score = e->weight;
            float nextbest = -1e30f;

            for (edge *f = g->adj[e->to]; f; f = f->next)
                if (!visited[f->to] && f->weight > nextbest)
                    nextbest = f->weight;

            if (nextbest > -1e20f)
                score += nextbest;

            if (!best) {
                best = e;
                best_score = score;
            } else if (score > best_score) {
                best = e;
                best_score = score;
            } else if (score == best_score && (rand() % 2 == 0)) {
                best = e;
                best_score = score;
            }
        }

        if (!best) break;

        total += best->weight;
        current = best->to;

        tmp[(*len)++] = current;
        visited[current] = 1;
    }

    free(visited);
    return total;
}

/* -----------------------------------------------
   Worker thread
   ----------------------------------------------- */

void* worker(void *arg) {
    shared_t *S = arg;
    graph *g = S->g;

    size_t *tmp = malloc(g->n * sizeof(size_t));
    size_t len = 0;

    while (!interrupted) {
        size_t s = (size_t)(rand() % g->n);

        float out;
        int r = rand() % 4;

        if (r == 0)
            out = run_sim_basic(g, s, tmp, &len);
        else if (r == 1)
            out = run_sim_tiebreak(g, s, tmp, &len);
        else if (r == 2)
            out = run_sim_tiebreak_8020(g, s, tmp, &len);
        else
            out = run_sim_lookahead2(g, s, tmp, &len);

        pthread_mutex_lock(&S->lock);
        if (out > S->best_weight) {
            free(S->best_path);
            S->best_path = malloc(len * sizeof(size_t));
            for (size_t i = 0; i < len; i++)
                S->best_path[i] = tmp[i];
            S->best_len = len;
            S->best_weight = out;
            S->last_improve = now();
        }
        pthread_mutex_unlock(&S->lock);
    }

    free(tmp);
    return NULL;
}

/* -----------------------------------------------
   MAIN
   ----------------------------------------------- */

int main(void) {
    graph *g = graph_read();
    if (!g) return 1;
    if (g->n == 0) {
        graph_free(g);
        return 1;
    }

    signal(SIGINT, handle_signal);
    signal(SIGTERM, handle_signal);

    srand(time(NULL));

    shared_t S;
    S.g = g;
    S.best_weight = -1e30f;
    S.best_path = NULL;
    S.best_len = 0;
    S.last_improve = now();
    pthread_mutex_init(&S.lock, NULL);

    pthread_t threads[NUM_THREADS];

    for (int i = 0; i < NUM_THREADS; i++)
        pthread_create(&threads[i], NULL, worker, &S);

    while (!interrupted && now() - S.last_improve < MAX_TIME) {
        struct timespec ts = {0, 10000000};
        nanosleep(&ts, NULL);
    }

    interrupted = 1;

    for (int i = 0; i < NUM_THREADS; i++)
        pthread_join(threads[i], NULL);

    printf("%.0f\n", S.best_weight);

    for (size_t i = 0; i < S.best_len; i++) {
        printf("%s", g->names[S.best_path[i]]);
        if (i + 1 < S.best_len) printf(" ");
    }
    printf("\n");

    free(S.best_path);
    pthread_mutex_destroy(&S.lock);
    graph_free(g);

    return 0;
}
